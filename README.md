## ðŸ“˜ Project Overview

This repository documents my work from **CS2321: Data Structures**, a core computer science course I completed at **Michigan Technological University** in **Spring 2023**. The class was taught by **Professor Ruihong Zhang** and emphasized rigorous implementation of fundamental data structures and algorithms in **Java**, without using built-in Java collections.

All projects were coded from scratch based on the textbook:  **_Data Structures and Algorithms in Java (6th Edition)_ by Goodrich & Tamassia**

## ðŸ“‚ Data Structures & Algorithms Implemented

| # | Topic                        | Description |
|---|-----------------------------|-------------|
| 1 | [Stack & Queue](1.%20Stack%20and%20Queue)       | Linked list stack, circular array queue, Josephus problem, postfix evaluation |
| 2 | [Lists](2.%20ArrayList%20and%20LinkedList)                    | ArrayList, DoublyLinkedList, PositionalList, and LRU-style customer tracker |
| 3 | [Trees](3.%20Binary%20Tree)                    | Linked binary tree, expression tree, recursive and level-order traversal |
| 4 | [Heaps & Priority Queues](4.%20Heap%20and%20Priority%20Queue) | Adaptable PQ with location-aware heap, comparator use, replace/remove key |
| 5 | [Greedy Algorithms](5.%20Greedy%20Algorithm)         | Fractional knapsack, task scheduling using PQ |
| 6 | [Sorting Algorithms](6.%20Sorts%20Algorithms)         | Insertion, Selection, HeapPQSort, MergeSort, QuickSort + performance charts |
| 7 | [Maps](7.%20HashMap)                     | UnorderedMap, SortedTable, HashMap with separate chaining, Binary Search Tree |
| 8 | [Graphs â€“ ADT](8.%20Graph)             | Graph with adjacency map, location-aware vertices/edges |
| 9 | [Graph Traversals](9.%20Graph%20Algorithms) | DFS, BFS, Dijkstraâ€™s shortest path over a city map |

## ðŸ§  Key Learnings

- Gained hands-on experience designing and implementing core **Abstract Data Types (ADTs)** from scratch in Java
- Practiced **object-oriented design principles**, including encapsulation, inheritance, and the use of generics
- Learned to write **JUnit test cases** to validate each component rigorously, covering standard and edge cases
- Analyzed and annotated **time complexity** using custom annotations like `@TimeComplexity`
- Applied **algorithmic paradigms** such as greedy algorithms, divide-and-conquer, and graph traversal
- Built **performance benchmarks** to compare sorting algorithms (e.g., O(nÂ²) vs O(n log n)) using actual runtime data
- Implemented **location-aware data structures**, such as Adaptable Priority Queues and Adjacency Map Graphs
- Reinforced the discipline of **clean, modular, and maintainable code** under strict academic and technical standards
