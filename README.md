## ðŸ“˜ Project Overview

This repository documents my work from **CS2321: Data Structures**, a core computer science course I completed at **Michigan Technological University** in **Spring 2023**. The class was taught by **Professor Ruihong Zhang** and emphasized rigorous implementation of fundamental data structures and algorithms in **Java**, without using built-in Java collections.

All projects were coded from scratch based on the textbook:  **_Data Structures and Algorithms in Java (6th Edition)_ by Goodrich & Tamassia**

## ðŸ“‚ Data Structures & Algorithms Implemented

| # | Topic                        | Description |
|---|-----------------------------|-------------|
| 1 | [Stack & Queue](assignment1_stack_queue)       | Linked list stack, circular array queue, Josephus problem, postfix evaluation |
| 2 | [Lists](assignment2_list)                    | ArrayList, DoublyLinkedList, PositionalList, and LRU-style customer tracker |
| 3 | [Trees](assignment3_tree)                    | Linked binary tree, expression tree, recursive and level-order traversal |
| 4 | [Heaps & Priority Queues](assignment4_heap_apq) | Adaptable PQ with location-aware heap, comparator use, replace/remove key |
| 5 | [Greedy Algorithms](assignment5_greedy)        | Fractional knapsack, task scheduling using PQ |
| 6 | [Sorting Algorithms](assignment6_sort)         | Insertion, Selection, HeapPQSort, MergeSort, QuickSort + performance charts |
| 7 | [Maps](assignment7_map)                       | UnorderedMap, SortedTable, HashMap with separate chaining, Binary Search Tree |
| 8 | [Graphs â€“ ADT](assignment8_graph)             | Graph with adjacency map, location-aware vertices/edges |
| 9 | [Graph Traversals](assignment9_graph_traversal) | DFS, BFS, Dijkstraâ€™s shortest path over a city map |

## ðŸ§  Key Learnings

- Gained hands-on experience designing and implementing core **Abstract Data Types (ADTs)** from scratch in Java
- Practiced **object-oriented design principles**, including encapsulation, inheritance, and the use of generics
- Learned to write **JUnit test cases** to validate each component rigorously, covering standard and edge cases
- Analyzed and annotated **time complexity** using custom annotations like `@TimeComplexity`
- Applied **algorithmic paradigms** such as greedy algorithms, divide-and-conquer, and graph traversal
- Built **performance benchmarks** to compare sorting algorithms (e.g., O(nÂ²) vs O(n log n)) using actual runtime data
- Implemented **location-aware data structures**, such as Adaptable Priority Queues and Adjacency Map Graphs
- Reinforced the discipline of **clean, modular, and maintainable code** under strict academic and technical standards
